#!/bin/bash

# prevent from multiple running
SHELL_SCRIPT=$(basename "$0")
PROCESS_SHELL_COUNT=$(pgrep -c "${SHELL_SCRIPT}")
if [ "$PROCESS_SHELL_COUNT" -gt 1 ]; then
    echo -e "not allowed to run multiple..."
    exit 10
fi

APP_WORKSPACE="{{ remote_app_path }}"
MODULE_NAME="{{ module_name }}"
PORT=$1

# nginx proxy
PROXY_CONF_FILE=/etc/nginx/conf.d/${MODULE_NAME}.conf
PROXY_TARGET_UPSTREAM="server 127.0.0.1"

# app
SPRING_PROFILE="{{ spring_profile }}"
STD_OUT=${APP_WORKSPACE}/logs/stdout_${PORT}.log
STD_ERR=${APP_WORKSPACE}/logs/stderr_${PORT}.log

# port group
BLUE=${APP_WORKSPACE}/BLUE
GREEN=${APP_WORKSPACE}/GREEN

# check group app runnable before deploy (param: group_file)
check_group_runnable() {
  local target_port_file=$1
  local target_group_name
  target_group_name=$(basename "$target_port_file")

  echo "-----------------------------------------"
  printf "[CHECK $target_group_name RUNNABLE] ports: (%s)\n" "${target_port_file[@]}"
  echo "-----------------------------------------"

  readarray -t target_ports < "${target_port_file}"
  for port in "${target_ports[@]}";
  do
    current_pid=$(pgrep -f "java.*${port}")
    if [ -n "${current_pid}" ];
    then
      echo "$target_group_name($port) already running"
      exit 50
    fi
  done

  echo "$target_group_name runnable!!"
}

# health check application (param: port)
CHECK_MAX_COUNT=10
CHECK_COUNT=0
app_health_check() {
  echo ">> application(${target_port}) health check"
  local target_port=$1

  if [ $CHECK_COUNT -gt $CHECK_MAX_COUNT ];
  then
    echo "Failure of running java application($target_port)"
    exit 50
  fi

  status_code=$(curl --connect-timeout 1 --max-time 3 -i -X GET http://localhost:"$target_port"/monitoring/health | awk '/HTTP\/1/{print $2}')
  if [[ $status_code =~ ^2[0-9]{2}$ ]];
  then
    echo "application($target_port) health check > UP"
  else
    echo "application($target_port) health check > DOWN"
    sleep 3
    CHECK_COUNT=$(expr ${CHECK_COUNT} + 1)
    app_health_check "${target_port}"
  fi
}

# run app (param: port)
run_app() {
  local target_port=$1

  nohup java -jar \
    -Dspring.profiles.active="${SPRING_PROFILE}" \
    -Dserver.port="${target_port}" \
    "${APP_WORKSPACE}"/"${MODULE_NAME}".jar 1>"${STD_OUT}" 2>"${STD_ERR}" &

  app_health_check "${target_port}"
}

# run group application (param: group_file)
run_group_app() {
  local target_port_file=$1
  local target_group_name
  target_group_name=$(basename "$target_port_file")

  echo "-----------------------------------------"
  printf "[RUN APP] ${target_group_name} (%s)\n" "${target_port_file[@]}"
  echo "-----------------------------------------"

  cd "${APP_WORKSPACE}" || exit 40

  echo ">> run java application"
  if ! java --version;
  then
    echo "no JRE setup > JRE is required!!"
    exit 50
  fi

  readarray -t target_ports < "${target_port_file}"
  for port in "${target_ports[@]}";
  do
    run_app "$port"
  done
}

# toggle proxy upstream status (param: port, toggle_status(up/down))
toggle_proxy_upstream() {
  local target_port=$1
  local toggle_status=$2

  local target_proxy_upstream
  target_proxy_upstream="${PROXY_TARGET_UPSTREAM}:${target_port}"
  local from_upstream_status  # regex
  local to_upstream_status

  case ${toggle_status} in
    up)
      from_upstream_status="${target_proxy_upstream}\sdown;"
      to_upstream_status="${target_proxy_upstream};"
      ;;
    down)
      from_upstream_status="${target_proxy_upstream};"
      to_upstream_status="${target_proxy_upstream} down;"
      ;;
    *)
      echo "[func_toggle_proxy_upstream] Invalid command - ${target_port}(${toggle_status})"
      exit 40;
      ;;
  esac

  echo ">> proxy upstream ${target_port} ${toggle_status}"
  target_upstream_status=$(grep "${to_upstream_status}" "${PROXY_CONF_FILE}")
  if [ -n "${target_upstream_status}" ]
  then
    echo "proxy upstream ${target_port} status - already ${toggle_status}"
  else
    echo "proxy upstream ${target_port} setting ${toggle_status}"
    sudo sed -i "s/\(${from_upstream_status}\)/${to_upstream_status}/g" "${PROXY_CONF_FILE}"
  fi
}

# toggle proxy upstream group status (param: group_file, toggle_status(up/down))
toggle_proxy_upstream_group() {
  local target_port_file=$1
  local toggle_status=$2
  local target_group_name
  target_group_name=$(basename "$target_port_file")

  readarray -t target_ports < "${target_port_file}"
  for port in "${target_ports[@]}";
  do
    toggle_proxy_upstream "${port}" "${toggle_status}"
  done
}

switch_proxy_upstream_group() {
  echo "-----------------------------------------"
  echo "[SWITCH GROUP] Blue - Green"
  echo "-----------------------------------------"

  toggle_proxy_upstream_group "${GREEN}" up
  toggle_proxy_upstream_group "${BLUE}" down

  if ! sudo nginx -t;
  then
    printf "Invalid nginx conf > switching proxy upstream group"
    exit 40
  fi

  sudo systemctl reload nginx
}

# shutdown application (param: port)
shutdown() {
  local target_port=$1

  echo ">> kill current running application(${target_port})"

  current_pid=$(pgrep -f "java.*${target_port}")
  if [ -z "${current_pid}" ];
  then
    echo "no current running application >> pass killing process"
  else
    echo "stop java application(${target_port}) - ${current_pid}"
    sudo kill -TERM "${current_pid}"
    sleep 5
  fi
}

# shutdown group application (param: group_file)
shutdown_group_app() {
  local target_port_file=$1
  local target_group_name
  target_group_name=$(basename "$target_port_file")

  echo "-----------------------------------------"
  printf "[SHUTDOWN APP] ${target_group_name} (%s)\n" "${target_port_file[@]}"
  echo "-----------------------------------------"

  readarray -t target_ports < "${target_port_file}"
  for port in "${target_ports[@]}";
  do
    shutdown "${port}" "${toggle_status}"
  done
}

main() {
  check_group_runnable "${GREEN}"

  run_group_app "${GREEN}"

  switch_proxy_upstream_group

  shutdown_group_app "${BLUE}"

  echo "## run application completed!!"
}

main
